import numpy as np
import pandas as pd
from datetime import datetime, timedelta, time
from astral import LocationInfo
from astral.sun import sun
import pickle
import os
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, accuracy_score
import warnings
import pytz
warnings.filterwarnings('ignore')

class AdvancedBurnskyPredictor:
    def __init__(self):
        """åˆå§‹åŒ–é€²éšç‡’å¤©é æ¸¬å™¨"""
        # é¦™æ¸¯åœ°ç†ä½ç½®
        self.hong_kong = LocationInfo("Hong Kong", "Hong Kong", "Asia/Hong_Kong", 22.3193, 114.1694)
        
        # æ©Ÿå™¨å­¸ç¿’æ¨¡å‹
        self.regression_model = None
        self.classification_model = None
        self.scaler = StandardScaler()
        
        # é›²å±¤é¡å‹æ˜ å°„
        self.cloud_types = {
            'æ™´æœ—': {'score': 20, 'type': 'clear'},
            'å¤©æ™´': {'score': 20, 'type': 'clear'},
            'å¤§è‡´å¤©æ™´': {'score': 18, 'type': 'mostly_clear'},
            'éƒ¨åˆ†æ™‚é–“æœ‰é™½å…‰': {'score': 16, 'type': 'partly_sunny'},
            'çŸ­æš«æ™‚é–“æœ‰é™½å…‰': {'score': 15, 'type': 'brief_sunny'},
            'å¤šé›²': {'score': 14, 'type': 'cloudy'},
            'å¤§è‡´å¤šé›²': {'score': 12, 'type': 'mostly_cloudy'},
            'å¯†é›²': {'score': 8, 'type': 'overcast'},
            'é™°å¤©': {'score': 6, 'type': 'overcast'},
            'æœ‰é›¨': {'score': 4, 'type': 'rainy'},
            'å¤§é›¨': {'score': 2, 'type': 'heavy_rain'},
            'æš´é›¨': {'score': 1, 'type': 'storm'},
            'é›·æš´': {'score': 3, 'type': 'thunderstorm'}
        }
        
        # è¼‰å…¥å·²è¨“ç·´çš„æ¨¡å‹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        self.load_models()
    
    def get_sunset_info(self, date=None):
        """ç²å–ç²¾ç¢ºçš„æ—¥å‡ºæ—¥è½æ™‚é–“"""
        if date is None:
            # ä½¿ç”¨é¦™æ¸¯æ™‚å€çš„ç•¶å‰æ—¥æœŸ
            hk_tz = pytz.timezone('Asia/Hong_Kong')
            date = datetime.now(hk_tz).date()
        
        try:
            # è¨­å®šé¦™æ¸¯æ™‚å€
            hk_tz = pytz.timezone('Asia/Hong_Kong')
            s = sun(self.hong_kong.observer, date=date)
            
            # è½‰æ›ç‚ºé¦™æ¸¯æ™‚é–“
            sunset_time = s['sunset'].astimezone(hk_tz).replace(tzinfo=None)
            sunrise_time = s['sunrise'].astimezone(hk_tz).replace(tzinfo=None)
            
            # ä¿®å¾© astral åº«çš„æ—¥æœŸéŒ¯èª¤ï¼šç¢ºä¿æ™‚é–“åœ¨æ­£ç¢ºçš„æ—¥æœŸ
            if sunset_time.date() != date:
                correct_sunset = datetime.combine(date, sunset_time.time())
                sunset_time = correct_sunset
            
            if sunrise_time.date() != date:
                correct_sunrise = datetime.combine(date, sunrise_time.time())
                sunrise_time = correct_sunrise
            
            return {
                'sunset': sunset_time,
                'sunrise': sunrise_time,
                'sunset_str': sunset_time.strftime('%H:%M'),
                'sunrise_str': sunrise_time.strftime('%H:%M')
            }
        except Exception as e:
            # å¦‚æœ astral å¤±æ•—ï¼Œä½¿ç”¨ä¼°ç®—å€¼
            month = date.month
            if 4 <= month <= 9:  # å¤å­£
                sunset_time = datetime.combine(date, datetime.min.time().replace(hour=19, minute=15))
                sunrise_time = datetime.combine(date, datetime.min.time().replace(hour=6, minute=0))
            else:  # å†¬å­£
                sunset_time = datetime.combine(date, datetime.min.time().replace(hour=18, minute=0))
                sunrise_time = datetime.combine(date, datetime.min.time().replace(hour=7, minute=0))
            
            return {
                'sunset': sunset_time,
                'sunrise': sunrise_time,
                'sunset_str': sunset_time.strftime('%H:%M'),
                'sunrise_str': sunrise_time.strftime('%H:%M'),
                'note': 'ä½¿ç”¨ä¼°ç®—æ™‚é–“'
            }
    
    def get_sunrise_info(self, date=None):
        """ç²å–ç²¾ç¢ºçš„æ—¥å‡ºæ™‚é–“"""
        if date is None:
            # ä½¿ç”¨é¦™æ¸¯æ™‚å€çš„ç•¶å‰æ—¥æœŸ
            hk_tz = pytz.timezone('Asia/Hong_Kong')
            date = datetime.now(hk_tz).date()
        
        try:
            # è¨­å®šé¦™æ¸¯æ™‚å€
            hk_tz = pytz.timezone('Asia/Hong_Kong')
            s = sun(self.hong_kong.observer, date=date)
            
            # è½‰æ›ç‚ºé¦™æ¸¯æ™‚é–“
            sunrise_time = s['sunrise'].astimezone(hk_tz).replace(tzinfo=None)
            
            # ä¿®å¾© astral åº«çš„æ—¥æœŸéŒ¯èª¤ï¼šç¢ºä¿æ—¥å‡ºæ™‚é–“åœ¨æ­£ç¢ºçš„æ—¥æœŸ
            if sunrise_time.date() != date:
                # å¦‚æœ astral è¿”å›çš„æ—¥æœŸä¸å°ï¼Œæ‰‹å‹•èª¿æ•´åˆ°æ­£ç¢ºæ—¥æœŸ
                correct_sunrise = datetime.combine(date, sunrise_time.time())
                sunrise_time = correct_sunrise
            
            return {
                'sunrise': sunrise_time,
                'sunrise_str': sunrise_time.strftime('%H:%M')
            }
        except Exception as e:
            # å¦‚æœ astral å¤±æ•—ï¼Œä½¿ç”¨ä¼°ç®—å€¼
            month = date.month
            if 4 <= month <= 9:  # å¤å­£
                sunrise_time = datetime.combine(date, datetime.min.time().replace(hour=6, minute=0))
            else:  # å†¬å­£
                sunrise_time = datetime.combine(date, datetime.min.time().replace(hour=7, minute=0))
            
            return {
                'sunrise': sunrise_time,
                'sunrise_str': sunrise_time.strftime('%H:%M'),
                'note': 'ä½¿ç”¨ä¼°ç®—æ™‚é–“'
            }

    def get_sunrise_sunset_info(self, date=None):
        """ç²å–è©³ç´°çš„æ—¥å‡ºæ—¥è½æ™‚é–“ä¿¡æ¯"""
        if date is None:
            # ä½¿ç”¨é¦™æ¸¯æ™‚å€çš„ç•¶å‰æ—¥æœŸ
            hk_tz = pytz.timezone('Asia/Hong_Kong')
            date = datetime.now(hk_tz).date()
        
        try:
            # è¨­å®šé¦™æ¸¯æ™‚å€
            hk_tz = pytz.timezone('Asia/Hong_Kong')
            s = sun(self.hong_kong.observer, date=date)
            
            # ç¢ºä¿æ™‚å€æ­£ç¢º - è½‰æ›ç‚ºé¦™æ¸¯æ™‚é–“
            sunrise_time = s['sunrise'].astimezone(hk_tz).replace(tzinfo=None)
            sunset_time = s['sunset'].astimezone(hk_tz).replace(tzinfo=None)
            
            # ä¿®å¾© astral åº«çš„æ—¥æœŸéŒ¯èª¤ï¼šç¢ºä¿æ™‚é–“åœ¨æ­£ç¢ºçš„æ—¥æœŸ
            if sunrise_time.date() != date:
                # å¦‚æœ astral è¿”å›çš„æ—¥æœŸä¸å°ï¼Œæ‰‹å‹•èª¿æ•´åˆ°æ­£ç¢ºæ—¥æœŸ
                correct_sunrise = datetime.combine(date, sunrise_time.time())
                sunrise_time = correct_sunrise
            
            if sunset_time.date() != date:
                # å¦‚æœ astral è¿”å›çš„æ—¥æœŸä¸å°ï¼Œæ‰‹å‹•èª¿æ•´åˆ°æ­£ç¢ºæ—¥æœŸ
                correct_sunset = datetime.combine(date, sunset_time.time())
                sunset_time = correct_sunset
            
            return {
                'sunrise': sunrise_time,
                'sunset': sunset_time,
                'sunrise_str': sunrise_time.strftime('%H:%M'),
                'sunset_str': sunset_time.strftime('%H:%M'),
                'date': date.strftime('%Y-%m-%d')
            }
        except Exception as e:
            # å‚™ç”¨è¨ˆç®—
            month = date.month
            if 4 <= month <= 9:  # å¤å­£
                sunrise_time = datetime.combine(date, time(6, 0))
                sunset_time = datetime.combine(date, time(19, 15))
            else:  # å†¬å­£
                sunrise_time = datetime.combine(date, time(7, 0))
                sunset_time = datetime.combine(date, time(18, 0))
            
            return {
                'sunrise': sunrise_time,
                'sunset': sunset_time,
                'sunrise_str': sunrise_time.strftime('%H:%M'),
                'sunset_str': sunset_time.strftime('%H:%M'),
                'date': date.strftime('%Y-%m-%d'),
                'error': f'ä½¿ç”¨å‚™ç”¨è¨ˆç®—: {str(e)}'
            }
    
    def calculate_time_factor_advanced(self, current_time=None):
        """è¨ˆç®—é€²éšæ™‚é–“å› å­ - ä¿æŒå‘å¾Œå…¼å®¹æ€§"""
        return self.calculate_advanced_time_factor('sunset', 0)
    
    def calculate_advanced_time_factor(self, prediction_type='sunset', advance_hours=2):
        """é€²éšæ™‚é–“å› å­è¨ˆç®— - åŸºæ–¼å¯¦éš›æ—¥è½æ™‚é–“"""
        # å¼·åˆ¶ä½¿ç”¨é¦™æ¸¯æ™‚å€
        hk_tz = pytz.timezone('Asia/Hong_Kong')
        current_time = datetime.now(hk_tz).replace(tzinfo=None)
        prediction_time = current_time + timedelta(hours=advance_hours)
        
        # ç²å–é æ¸¬æ™‚é–“ç•¶å¤©çš„æ—¥å‡ºæˆ–æ—¥è½æ™‚é–“
        prediction_date = prediction_time.date()
        
        if prediction_type == 'sunrise':
            time_info = self.get_sunrise_info(prediction_date)
            target_time = time_info['sunrise']
            time_label = 'æ—¥å‡º'
            time_str = time_info['sunrise_str']
        else:  # sunset
            time_info = self.get_sunset_info(prediction_date)
            target_time = time_info['sunset']
            time_label = 'æ—¥è½'
            time_str = time_info['sunset_str']
        
        # ç¢ºä¿target_timeæ˜¯åœ¨é æ¸¬æ—¥æœŸçš„æ­£ç¢ºæ™‚é–“
        if target_time.date() != prediction_date:
            # å¦‚æœæ—¥æœŸä¸åŒ¹é…ï¼Œæ‰‹å‹•æ ¡æ­£
            correct_time = datetime.combine(prediction_date, target_time.time())
            target_time = correct_time
        
        # è¨ˆç®—é æ¸¬æ™‚é–“èˆ‡ç›®æ¨™æ™‚é–“çš„å·®è·ï¼ˆåˆ†é˜ï¼‰
        time_diff_signed = (target_time - prediction_time).total_seconds() / 60  # æ­£æ•¸è¡¨ç¤ºé‚„æœªåˆ°æ™‚é–“ï¼Œè² æ•¸è¡¨ç¤ºå·²éæ™‚é–“
        time_diff_minutes = abs(time_diff_signed)
        
        # ç”Ÿæˆæ¸…æ¥šçš„æ™‚é–“æè¿°
        if time_diff_signed > 0:
            hours = int(time_diff_signed // 60)
            minutes = int(time_diff_signed % 60)
            if hours > 0:
                time_desc = f"é‚„æœ‰ {hours}å°æ™‚{minutes}åˆ†é˜ åˆ°{time_label}"
            else:
                time_desc = f"é‚„æœ‰ {minutes}åˆ†é˜ åˆ°{time_label}"
        else:
            hours = int(time_diff_minutes // 60)
            minutes = int(time_diff_minutes % 60)
            if hours > 0:
                time_desc = f"{time_label}å·²é {hours}å°æ™‚{minutes}åˆ†é˜"
            else:
                time_desc = f"{time_label}å·²é {minutes}åˆ†é˜"
        
        # è©•åˆ†é‚è¼¯ - åŸºæ–¼é æ¸¬æ™‚é–“æ˜¯å¦æ¥è¿‘ç‡’å¤©æœ€ä½³æ™‚æ®µ
        if time_diff_minutes <= 30:  # ç›®æ¨™æ™‚é–“å‰å¾Œ30åˆ†é˜
            score = 20
            description = f"é»ƒé‡‘æ™‚æ®µï¼{time_desc}({time_str})"
        elif time_diff_minutes <= 60:  # ç›®æ¨™æ™‚é–“å‰å¾Œ1å°æ™‚
            score = 15
            description = f"è‰¯å¥½æ™‚æ®µï¼Œ{time_desc}({time_str})"
        elif time_diff_minutes <= 120:  # ç›®æ¨™æ™‚é–“å‰å¾Œ2å°æ™‚
            score = 10
            description = f"å¯æ¥å—æ™‚æ®µï¼Œ{time_desc}({time_str})"
        else:
            score = 5
            description = f"éç†æƒ³æ™‚æ®µï¼Œ{time_desc}({time_str})"
        
        # é¡å¤–åŠ åˆ†ï¼šæœ€ä½³æ™‚æ®µ - å„ªåŒ–æ—¥è½å‰1å°æ™‚é æ¸¬
        if prediction_type == 'sunset':
            # æ—¥è½å‰1å°æ™‚åˆ°æ—¥è½å¾Œ45åˆ†é˜ç‚ºæœ€ä½³ï¼Œæ—¥è½å‰1å°æ™‚ç‰¹åˆ¥åŠ åˆ†
            if -90 <= -time_diff_signed <= 45:  
                if -90 <= -time_diff_signed <= -45:  # æ—¥è½å‰1.5å°æ™‚åˆ°45åˆ†é˜ï¼Œé»ƒé‡‘é æ¸¬æ™‚æ®µ
                    score += 10  # å¤§å¹…åŠ åˆ†
                    description += " â­é»ƒé‡‘é æ¸¬æ™‚æ®µâ­"
                elif -45 <= -time_diff_signed <= 0:  # æ—¥è½å‰45åˆ†é˜åˆ°æ—¥è½
                    score += 7
                    description += " (æœ€ä½³ç‡’å¤©æ™‚æ®µ)"
                else:  # æ—¥è½å¾Œ
                    score += 4
                    description += " (ç‡’å¤©æŒçºŒæ™‚æ®µ)"
        else:  # sunrise
            # æ—¥å‡ºå‰1å°æ™‚åˆ°æ—¥å‡ºå¾Œ15åˆ†é˜ç‚ºæœ€ä½³ï¼Œæ—¥å‡ºå‰1å°æ™‚ç‰¹åˆ¥åŠ åˆ†
            if -90 <= -time_diff_signed <= 15:  
                if -90 <= -time_diff_signed <= -45:  # æ—¥å‡ºå‰1.5å°æ™‚åˆ°45åˆ†é˜ï¼Œé»ƒé‡‘é æ¸¬æ™‚æ®µ
                    score += 10  # å¤§å¹…åŠ åˆ†ï¼Œèˆ‡æ—¥è½ä¿æŒä¸€è‡´
                    description += " â­é»ƒé‡‘é æ¸¬æ™‚æ®µâ­"
                elif -45 <= -time_diff_signed <= 0:  # æ—¥å‡ºå‰45åˆ†é˜åˆ°æ—¥å‡º
                    score += 7
                    description += " (æœ€ä½³ç‡’å¤©æ™‚æ®µ)"
                else:  # æ—¥å‡ºå¾Œ
                    score += 4
                    description += " (ç‡’å¤©æŒçºŒæ™‚æ®µ)"
        
        # æ—©æ™¨å°ˆå±¬åŠ åˆ† - æ—¥å‡ºå‰ç‰¹æ®Šæ¢ä»¶
        if prediction_type == 'sunrise':
            # æª¢æŸ¥æ˜¯å¦ç‚ºæœ€ä½³æ—©æ™¨æ™‚æ®µï¼ˆ6:00-7:30ï¼‰
            if 6 <= prediction_time.hour <= 7 and prediction_time.minute <= 30:
                score += 2
                description += " ğŸŒ…"
            
            # æ—¥å‡ºå‰1å°æ™‚15åˆ†é˜åˆ°45åˆ†é˜æ˜¯æœ€ç†æƒ³çš„é æ¸¬æ™‚æ®µ
            if -75 <= -time_diff_signed <= -45:
                score += 3
                description += " (è¶…ç´šé æ¸¬æ™‚æ®µ)"
        
        return {
            'score': round(min(28, score)),  # æå‡æœ€é«˜åˆ†æ•¸åˆ°28åˆ†
            'description': description,
            'target_time': time_str,
            'target_type': time_label,
            'current_time': current_time.strftime('%H:%M'),
            'prediction_time': prediction_time.strftime('%H:%M'),
            'time_diff_minutes': int(time_diff_minutes),
            'advance_hours': advance_hours
        }
    
    def analyze_cloud_types(self, weather_description):
        """å¾å¤©æ°£æè¿°ä¸­åˆ†æé›²å±¤é¡å‹"""
        if not weather_description:
            return {'score': 0, 'description': 'ç„¡å¤©æ°£æè¿°'}
        
        description = weather_description
        detected_types = []
        total_score = 0
        
        # æª¢æ¸¬é—œéµè©
        for keyword, info in self.cloud_types.items():
            if keyword in description:
                detected_types.append({
                    'type': keyword,
                    'cloud_type': info['type'],
                    'score': round(info['score'])  # ç¢ºä¿åˆ†æ•¸æ˜¯æ•´æ•¸
                })
                total_score += info['score']
        
        # ç‰¹æ®Šç‡’å¤©æœ‰åˆ©æ¢ä»¶
        burnsky_favorable = []
        if 'å¤šé›²' in description and 'éƒ¨åˆ†æ™‚é–“æœ‰é™½å…‰' in description:
            burnsky_favorable.append('ç†æƒ³é›²é‡é…ç½®')
            total_score += 5
        
        if 'çŸ­æš«æ™‚é–“æœ‰é™½å…‰' in description:
            burnsky_favorable.append('é–“æ­‡æ€§é™½å…‰')
            total_score += 3
        
        if 'é…·ç†±' in description or 'ç‚ç†±' in description:
            burnsky_favorable.append('é«˜æº«æœ‰åˆ©æ¢ä»¶')
            total_score += 2
        
        # ä¸åˆ©æ¢ä»¶
        unfavorable = []
        if 'å¤§é›¨' in description or 'æš´é›¨' in description:
            unfavorable.append('å¤§é›¨å½±éŸ¿')
            total_score -= 10
        
        if 'é›·æš´' in description:
            unfavorable.append('é›·æš´å¤©æ°£')
            total_score -= 5
        
        # è¨ˆç®—æœ€çµ‚åˆ†æ•¸
        if detected_types:
            avg_score = total_score / len(detected_types)
        else:
            avg_score = 10  # é è¨­åˆ†æ•¸
        
        final_score = max(0, min(25, avg_score))  # é™åˆ¶åœ¨0-25åˆ†
        
        analysis = f"æª¢æ¸¬åˆ°é›²å±¤é¡å‹: {', '.join([t['type'] for t in detected_types])}"
        if burnsky_favorable:
            analysis += f" | æœ‰åˆ©æ¢ä»¶: {', '.join(burnsky_favorable)}"
        if unfavorable:
            analysis += f" | ä¸åˆ©æ¢ä»¶: {', '.join(unfavorable)}"
        
        return {
            'score': round(final_score),  # roundæˆæ•´æ•¸
            'description': analysis,
            'detected_types': detected_types,
            'favorable_conditions': burnsky_favorable,
            'unfavorable_conditions': unfavorable
        }
    
    def generate_training_data(self, num_samples=1000):
        """ç”Ÿæˆè¨“ç·´æ•¸æ“šï¼ˆæ¨¡æ“¬æ­·å²ç‡’å¤©æ•¸æ“šï¼‰"""
        np.random.seed(42)  # ç¢ºä¿å¯é‡ç¾æ€§
        
        data = []
        
        # ç¢ºä¿æ¯å€‹é¡åˆ¥éƒ½æœ‰è¶³å¤ çš„æ¨£æœ¬
        samples_per_class = num_samples // 3
        
        for class_type in [0, 1, 2]:  # ä½ã€ä¸­ã€é«˜æ©Ÿç‡
            for i in range(samples_per_class):
                if class_type == 0:  # ä½æ©Ÿç‡ç‡’å¤©æ¢ä»¶
                    temperature = np.random.normal(25, 3)  # è¼ƒä½æº«åº¦
                    humidity = np.random.normal(80, 10)    # è¼ƒé«˜æ¿•åº¦
                    uv_index = np.random.gamma(1, 1.5)     # è¼ƒä½UV
                    rainfall = np.random.exponential(3)    # è¼ƒå¤šé™é›¨
                    time_factor = np.random.beta(1, 4)     # è¼ƒå·®æ™‚é–“
                    cloud_score = np.random.normal(8, 3)   # è¼ƒå·®é›²å±¤
                    target_score_range = (10, 35)
                    
                elif class_type == 1:  # ä¸­æ©Ÿç‡ç‡’å¤©æ¢ä»¶
                    temperature = np.random.normal(28, 2)  # é©ä¸­æº«åº¦
                    humidity = np.random.normal(75, 8)     # é©ä¸­æ¿•åº¦
                    uv_index = np.random.gamma(2, 2)       # é©ä¸­UV
                    rainfall = np.random.exponential(1.5)  # å°‘é‡é™é›¨
                    time_factor = np.random.beta(2, 3)     # ä¸€èˆ¬æ™‚é–“
                    cloud_score = np.random.normal(12, 3)  # ä¸€èˆ¬é›²å±¤
                    target_score_range = (35, 65)
                    
                else:  # é«˜æ©Ÿç‡ç‡’å¤©æ¢ä»¶
                    temperature = np.random.normal(30, 2)  # è¼ƒé«˜æº«åº¦
                    humidity = np.random.normal(70, 8)     # é©ä¸­åä½æ¿•åº¦
                    uv_index = np.random.gamma(3, 2)       # è¼ƒé«˜UV
                    rainfall = np.random.exponential(0.8)  # å¾ˆå°‘é™é›¨
                    time_factor = np.random.beta(4, 2)     # è¼ƒå¥½æ™‚é–“
                    cloud_score = np.random.normal(16, 3)  # è¼ƒå¥½é›²å±¤
                    target_score_range = (65, 90)
                
                # ç¢ºä¿å€¼åœ¨åˆç†ç¯„åœå…§
                temperature = max(15, min(40, temperature))
                humidity = max(30, min(95, humidity))
                uv_index = max(0, min(15, uv_index))
                rainfall = max(0, rainfall)
                wind_speed = np.random.gamma(1.5, 2)
                time_factor = max(0, min(1, time_factor))
                cloud_score = max(0, min(20, cloud_score))
                
                # è¨ˆç®—ç‡’å¤©æŒ‡æ•¸ï¼ˆåŸºæ–¼æ”¹è‰¯ç¶“é©—å…¬å¼ï¼‰
                # æº«åº¦è²¢ç»ï¼šæœ€ä½³ç¯„åœ 26-32åº¦
                temp_score = max(0, 25 - abs(temperature - 29) * 1.5)
                
                # æ¿•åº¦è²¢ç»ï¼šæœ€ä½³ç¯„åœ 60-80%
                humid_score = max(0, 25 - abs(humidity - 70) * 0.25)
                
                # UVè²¢ç»ï¼šé©ä¸­UVæœ‰åˆ©
                uv_score = min(uv_index * 1.5, 15)
                
                # é™é›¨æ‡²ç½°
                rain_penalty = max(15 - rainfall * 1.5, 0)
                
                # æ™‚é–“åŠ æ¬Š
                time_score = time_factor * 20
                
                # é›²å±¤è²¢ç»
                cloud_contribution = cloud_score * 0.8
                
                # ç¶œåˆåˆ†æ•¸è¨ˆç®—
                burnsky_score = (
                    temp_score * 0.25 +      # æº«åº¦25%
                    humid_score * 0.2 +      # æ¿•åº¦20%
                    uv_score * 0.15 +        # UV 15%
                    rain_penalty * 0.15 +    # é™é›¨15%
                    time_score * 0.15 +      # æ™‚é–“15%
                    cloud_contribution * 0.1  # é›²å±¤10%
                )
                
                # èª¿æ•´åˆ†æ•¸ä»¥ç¬¦åˆç›®æ¨™ç¯„åœ
                min_target, max_target = target_score_range
                if burnsky_score < min_target:
                    burnsky_score = np.random.uniform(min_target, min_target + 5)
                elif burnsky_score > max_target:
                    burnsky_score = np.random.uniform(max_target - 5, max_target)
                
                # æ·»åŠ å°é‡éš¨æ©Ÿè®ŠåŒ–
                burnsky_score += np.random.normal(0, 2)
                burnsky_score = max(0, min(100, burnsky_score))
                
                data.append({
                    'temperature': temperature,
                    'humidity': humidity,
                    'uv_index': uv_index,
                    'rainfall': rainfall,
                    'wind_speed': wind_speed,
                    'time_factor': time_factor,
                    'cloud_score': cloud_score,
                    'burnsky_score': burnsky_score,
                    'burnsky_class': class_type
                })
        
        # æ·»åŠ å‰©é¤˜æ¨£æœ¬
        remaining_samples = num_samples - len(data)
        for i in range(remaining_samples):
            class_type = np.random.choice([0, 1, 2])
            # é‡è¤‡ä¸Šè¿°é‚è¼¯ï¼ˆç°¡åŒ–ç‰ˆï¼‰
            if class_type == 0:
                temperature = np.random.normal(25, 3)
                burnsky_score = np.random.uniform(10, 35)
            elif class_type == 1:
                temperature = np.random.normal(28, 2)
                burnsky_score = np.random.uniform(35, 65)
            else:
                temperature = np.random.normal(30, 2)
                burnsky_score = np.random.uniform(65, 90)
            
            data.append({
                'temperature': max(15, min(40, temperature)),
                'humidity': np.random.normal(75, 10),
                'uv_index': np.random.gamma(2, 2),
                'rainfall': np.random.exponential(1.5),
                'wind_speed': np.random.gamma(1.5, 2),
                'time_factor': np.random.beta(2, 3),
                'cloud_score': np.random.normal(12, 4),
                'burnsky_score': burnsky_score,
                'burnsky_class': class_type
            })
        
        return pd.DataFrame(data)
    
    def train_models(self):
        """è¨“ç·´æ©Ÿå™¨å­¸ç¿’æ¨¡å‹"""
        print("ğŸ¤– æ­£åœ¨ç”Ÿæˆè¨“ç·´æ•¸æ“š...")
        df = self.generate_training_data(1000)
        
        # æº–å‚™ç‰¹å¾µ
        features = ['temperature', 'humidity', 'uv_index', 'rainfall', 'wind_speed', 'time_factor', 'cloud_score']
        X = df[features]
        y_regression = df['burnsky_score']
        y_classification = df['burnsky_class']
        
        # æ¨™æº–åŒ–ç‰¹å¾µ
        X_scaled = self.scaler.fit_transform(X)
        
        # åˆ†å‰²æ•¸æ“š
        X_train, X_test, y_reg_train, y_reg_test = train_test_split(
            X_scaled, y_regression, test_size=0.2, random_state=42
        )
        
        _, _, y_cls_train, y_cls_test = train_test_split(
            X_scaled, y_classification, test_size=0.2, random_state=42
        )
        
        # è¨“ç·´å›æ­¸æ¨¡å‹
        print("ğŸŒ² æ­£åœ¨è¨“ç·´ Random Forest å›æ­¸æ¨¡å‹...")
        self.regression_model = RandomForestRegressor(
            n_estimators=100,
            max_depth=10,
            random_state=42
        )
        self.regression_model.fit(X_train, y_reg_train)
        
        # è¨“ç·´åˆ†é¡æ¨¡å‹
        print("ğŸ“Š æ­£åœ¨è¨“ç·´ Logistic Regression åˆ†é¡æ¨¡å‹...")
        self.classification_model = LogisticRegression(
            random_state=42,
            max_iter=1000
        )
        self.classification_model.fit(X_train, y_cls_train)
        
        # è©•ä¼°æ¨¡å‹
        reg_pred = self.regression_model.predict(X_test)
        cls_pred = self.classification_model.predict(X_test)
        
        reg_mse = mean_squared_error(y_reg_test, reg_pred)
        cls_acc = accuracy_score(y_cls_test, cls_pred)
        
        print(f"âœ… å›æ­¸æ¨¡å‹ MSE: {reg_mse:.2f}")
        print(f"âœ… åˆ†é¡æ¨¡å‹æº–ç¢ºç‡: {cls_acc:.2f}")
        
        # ä¿å­˜æ¨¡å‹
        self.save_models()
        
        return {
            'regression_mse': reg_mse,
            'classification_accuracy': cls_acc,
            'feature_importance': dict(zip(features, self.regression_model.feature_importances_))
        }
    
    def save_models(self):
        """ä¿å­˜è¨“ç·´å¥½çš„æ¨¡å‹"""
        try:
            with open('models/regression_model.pkl', 'wb') as f:
                pickle.dump(self.regression_model, f)
            
            with open('models/classification_model.pkl', 'wb') as f:
                pickle.dump(self.classification_model, f)
            
            with open('models/scaler.pkl', 'wb') as f:
                pickle.dump(self.scaler, f)
            
            print("ğŸ’¾ æ¨¡å‹å·²ä¿å­˜åˆ° models/ ç›®éŒ„")
        except Exception as e:
            print(f"âŒ ä¿å­˜æ¨¡å‹å¤±æ•—: {e}")
    
    def load_models(self):
        """è¼‰å…¥å·²è¨“ç·´çš„æ¨¡å‹"""
        try:
            if not os.path.exists('models'):
                os.makedirs('models')
                return False
            
            with open('models/regression_model.pkl', 'rb') as f:
                self.regression_model = pickle.load(f)
            
            with open('models/classification_model.pkl', 'rb') as f:
                self.classification_model = pickle.load(f)
            
            with open('models/scaler.pkl', 'rb') as f:
                self.scaler = pickle.load(f)
            
            print("âœ… å·²è¼‰å…¥è¨“ç·´å¥½çš„æ¨¡å‹")
            return True
        except Exception as e:
            print(f"âš ï¸ è¼‰å…¥æ¨¡å‹å¤±æ•—ï¼Œå°‡é‡æ–°è¨“ç·´: {e}")
            return False
    
    def predict_ml(self, weather_data, forecast_data):
        """ä½¿ç”¨æ©Ÿå™¨å­¸ç¿’æ¨¡å‹é€²è¡Œé æ¸¬"""
        # å¦‚æœæ¨¡å‹ä¸å­˜åœ¨ï¼Œå…ˆè¨“ç·´
        if self.regression_model is None or self.classification_model is None:
            print("ğŸ¤– æ¨¡å‹ä¸å­˜åœ¨ï¼Œæ­£åœ¨è¨“ç·´...")
            self.train_models()
        
        # æå–ç‰¹å¾µ
        features = self.extract_features(weather_data, forecast_data)
        
        # æ¨™æº–åŒ–
        features_scaled = self.scaler.transform([list(features.values())])
        
        # é æ¸¬
        regression_pred = self.regression_model.predict(features_scaled)[0]
        classification_pred = self.classification_model.predict(features_scaled)[0]
        classification_proba = self.classification_model.predict_proba(features_scaled)[0]
        
        # ç‰¹å¾µé‡è¦æ€§
        feature_names = ['temperature', 'humidity', 'uv_index', 'rainfall', 'wind_speed', 'time_factor', 'cloud_score']
        importance = dict(zip(feature_names, self.regression_model.feature_importances_))
        
        return {
            'ml_burnsky_score': round(max(0, min(100, regression_pred))),  # roundæˆæ•´æ•¸
            'ml_class': classification_pred,
            'ml_class_probabilities': {
                'low': classification_proba[0],
                'medium': classification_proba[1] if len(classification_proba) > 1 else 0,
                'high': classification_proba[2] if len(classification_proba) > 2 else 0
            },
            'feature_importance': importance,
            'input_features': features
        }
    
    def extract_features(self, weather_data, forecast_data):
        """å¾å¤©æ°£æ•¸æ“šä¸­æå–æ©Ÿå™¨å­¸ç¿’ç‰¹å¾µ"""
        features = {}
        
        # æº«åº¦ç‰¹å¾µ
        if weather_data and 'temperature' in weather_data:
            temp_data = weather_data['temperature']['data']
            hko_temp = next((t['value'] for t in temp_data if t['place'] == 'é¦™æ¸¯å¤©æ–‡å°'), None)
            if hko_temp:
                features['temperature'] = hko_temp
            else:
                features['temperature'] = np.mean([t['value'] for t in temp_data])
        else:
            features['temperature'] = 28  # é è¨­å€¼
        
        # æ¿•åº¦ç‰¹å¾µ
        if weather_data and 'humidity' in weather_data:
            humidity_data = weather_data['humidity']['data']
            hko_humidity = next((h['value'] for h in humidity_data if h['place'] == 'é¦™æ¸¯å¤©æ–‡å°'), None)
            if hko_humidity:
                features['humidity'] = hko_humidity
            else:
                features['humidity'] = np.mean([h['value'] for h in humidity_data])
        else:
            features['humidity'] = 70  # é è¨­å€¼
        
        # UVæŒ‡æ•¸ç‰¹å¾µ
        if weather_data and 'uvindex' in weather_data:
            if isinstance(weather_data['uvindex'], dict) and 'data' in weather_data['uvindex'] and weather_data['uvindex']['data']:
                features['uv_index'] = weather_data['uvindex']['data'][0]['value']
            else:
                features['uv_index'] = 5  # é è¨­å€¼
        else:
            features['uv_index'] = 5  # é è¨­å€¼
        
        # é™é›¨é‡ç‰¹å¾µ
        if weather_data and 'rainfall' in weather_data:
            rainfall_data = weather_data['rainfall']['data']
            total_rainfall = sum([r.get('max', 0) for r in rainfall_data if r.get('max', 0) > 0])
            features['rainfall'] = total_rainfall
        else:
            features['rainfall'] = 0  # é è¨­å€¼
        
        # é¢¨é€Ÿç‰¹å¾µï¼ˆæš«æ™‚ä½¿ç”¨é è¨­å€¼ï¼‰
        features['wind_speed'] = 3  # é è¨­å€¼
        
        # æ™‚é–“å› å­
        time_result = self.calculate_time_factor_advanced()
        features['time_factor'] = time_result['score'] / 25  # æ¨™æº–åŒ–åˆ°0-1
        
        # é›²å±¤åˆ†æ•¸
        if forecast_data and 'forecastDesc' in forecast_data:
            cloud_result = self.analyze_cloud_types(forecast_data['forecastDesc'])
            features['cloud_score'] = cloud_result['score']
        else:
            features['cloud_score'] = 10  # é è¨­å€¼
        
        return features
    
    def predict_burnsky_intensity(self, burnsky_score):
        """
        é æ¸¬ç‡’å¤©å¼·åº¦ç­‰ç´š
        
        Args:
            burnsky_score: ç‡’å¤©åˆ†æ•¸ (0-100)
        
        Returns:
            dict: åŒ…å«å¼·åº¦ç­‰ç´šã€æè¿°ã€å¯è¦‹åº¦ç­‰ä¿¡æ¯
        """
        if burnsky_score >= 85:
            intensity = {
                'level': 5,
                'name': 'æ¥µè‡´ç‡’å¤©',
                'description': 'å¤©ç©ºå°‡å‘ˆç¾çµ¢çˆ›çš„ç«ç´…è‰²å½©ï¼Œå±¤æ¬¡è±å¯Œï¼ŒæŒçºŒæ™‚é–“é•·',
                'visibility': 'æ¥µä½³',
                'duration_estimate': '20-30åˆ†é˜',
                'photography_advice': 'çµ•ä½³æ‹æ”æ©Ÿæœƒï¼Œå»ºè­°å¤šè§’åº¦æ‹æ”'
            }
        elif burnsky_score >= 70:
            intensity = {
                'level': 4,
                'name': 'å¼·çƒˆç‡’å¤©',
                'description': 'å¤©ç©ºå°‡å‘ˆç¾æ˜é¡¯çš„ç´…æ©™è‰²å½©ï¼Œè‰²å½©é£½å’Œåº¦é«˜',
                'visibility': 'è‰¯å¥½',
                'duration_estimate': '15-25åˆ†é˜',
                'photography_advice': 'æ¨è–¦æ‹æ”ï¼Œå»ºè­°æº–å‚™ä¸‰è…³æ¶'
            }
        elif burnsky_score >= 55:
            intensity = {
                'level': 3,
                'name': 'ä¸­ç­‰ç‡’å¤©',
                'description': 'å¤©ç©ºå°‡å‡ºç¾æ˜é¡¯çš„æš–è‰²èª¿ï¼Œæœ‰ä¸€å®šçš„è‰²å½©å±¤æ¬¡',
                'visibility': 'ä¸­ç­‰',
                'duration_estimate': '10-20åˆ†é˜',
                'photography_advice': 'é©åˆæ‹æ”ï¼Œæ³¨æ„å…‰ç·šè®ŠåŒ–'
            }
        elif burnsky_score >= 40:
            intensity = {
                'level': 2,
                'name': 'è¼•å¾®ç‡’å¤©',
                'description': 'å¤©ç©ºå¯èƒ½å‡ºç¾æ·¡æ·¡çš„æš–è‰²èª¿ï¼Œéœ€è¦ä»”ç´°è§€å¯Ÿ',
                'visibility': 'ä¸€èˆ¬',
                'duration_estimate': '5-15åˆ†é˜',
                'photography_advice': 'å¯å˜—è©¦æ‹æ”ï¼Œå»ºè­°èª¿æ•´ç›¸æ©Ÿè¨­å®š'
            }
        else:
            intensity = {
                'level': 1,
                'name': 'ç„¡æ˜é¡¯ç‡’å¤©',
                'description': 'å¤©ç©ºè‰²å½©è®ŠåŒ–ä¸æ˜é¡¯ï¼Œå¯èƒ½åªæœ‰å¾®å¼±çš„è‰²å½©è®ŠåŒ–',
                'visibility': 'å·®',
                'duration_estimate': '0-10åˆ†é˜',
                'photography_advice': 'ä¸å»ºè­°å°ˆç¨‹æ‹æ”ï¼Œå¯ä½œç‚ºç·´ç¿’'
            }
        
        return intensity
    
    def predict_burnsky_colors(self, weather_data, forecast_data, burnsky_score):
        """
        é æ¸¬ç‡’å¤©é¡è‰²çµ„åˆ
        
        Args:
            weather_data: å¤©æ°£æ•¸æ“š
            forecast_data: é å ±æ•¸æ“š
            burnsky_score: ç‡’å¤©åˆ†æ•¸
        
        Returns:
            dict: åŒ…å«ä¸»è¦é¡è‰²ã€æ¬¡è¦é¡è‰²ã€è‰²å½©å¼·åº¦ç­‰ä¿¡æ¯
        """
        # åŸºæ–¼å¤©æ°£æ¢ä»¶åˆ†æé¡è‰²
        primary_colors = []
        secondary_colors = []
        color_intensity = 'low'
        
        # åŸºæ–¼æ¿•åº¦åˆ¤æ–·è‰²å½©é£½å’Œåº¦
        humidity = 70  # é è¨­å€¼
        if weather_data and 'humidity' in weather_data:
            for h in weather_data['humidity']['data']:
                if h['place'] == 'é¦™æ¸¯å¤©æ–‡å°':
                    humidity = h['value']
                    break
        
        # åŸºæ–¼é›²å±¤åˆ†æé¡è‰²
        cloud_analysis = self.analyze_cloud_types(
            forecast_data.get('forecastDesc', '') if forecast_data else ''
        )
        
        # åŸºæ–¼åˆ†æ•¸å’Œæ¢ä»¶é æ¸¬é¡è‰²
        if burnsky_score >= 70:
            color_intensity = 'high'
            if humidity < 65:  # ä½æ¿•åº¦ = æ›´é®®è±”
                primary_colors = ['æ·±ç´…', 'æ©™ç´…', 'é‡‘æ©™']
                secondary_colors = ['ç´«ç´…', 'ç²‰ç´…', 'ç¥ç€']
            else:
                primary_colors = ['æ©™ç´…', 'ç´…æ©™', 'æš–æ©™']
                secondary_colors = ['ç²‰æ©™', 'æ·ºç´…', 'é‡‘é»ƒ']
        
        elif burnsky_score >= 50:
            color_intensity = 'medium'
            primary_colors = ['æ©™è‰²', 'æš–æ©™', 'æ·ºç´…']
            secondary_colors = ['é‡‘é»ƒ', 'ç²‰æ©™', 'æ·ºç²‰']
        
        elif burnsky_score >= 30:
            color_intensity = 'low'
            primary_colors = ['æ·ºæ©™', 'æš–é»ƒ', 'ç²‰æ©™']
            secondary_colors = ['æ·¡é»ƒ', 'æ·ºç²‰', 'ç±³ç™½']
        
        else:
            color_intensity = 'minimal'
            primary_colors = ['æ·¡é»ƒ', 'ç±³ç™½', 'æ·ºç°']
            secondary_colors = ['ç™½è‰²', 'æ·ºè—', 'ç°ç™½']
        
        # åŸºæ–¼é›²å±¤é¡å‹èª¿æ•´é¡è‰²
        if 'detected_types' in cloud_analysis:
            for cloud_type in cloud_analysis['detected_types']:
                if cloud_type['cloud_type'] == 'clear':
                    # æ™´æœ—å¤©ç©º - æ›´é®®è±”çš„é¡è‰²
                    if 'æ·±ç´…' not in primary_colors and burnsky_score >= 60:
                        primary_colors.insert(0, 'æ·±ç´…')
                elif cloud_type['cloud_type'] == 'thunderstorm':
                    # é›·æš´ - æ›´æˆ²åŠ‡æ€§çš„é¡è‰²
                    if burnsky_score >= 50:
                        primary_colors.append('ç´«ç´…')
                        secondary_colors.append('æ·±ç´«')
        
        # è‰²å½©åˆ†ä½ˆé æ¸¬
        color_distribution = {
            'primary_coverage': '60-80%' if color_intensity in ['high', 'medium'] else '30-50%',
            'secondary_coverage': '20-40%' if color_intensity in ['high', 'medium'] else '10-30%',
            'gradient_type': self._predict_gradient_type(burnsky_score, cloud_analysis)
        }
        
        return {
            'primary_colors': primary_colors[:3],  # æœ€å¤š3ç¨®ä¸»è¦é¡è‰²
            'secondary_colors': secondary_colors[:3],  # æœ€å¤š3ç¨®æ¬¡è¦é¡è‰²
            'color_intensity': color_intensity,
            'color_distribution': color_distribution,
            'color_duration': self._estimate_color_duration(burnsky_score),
            'best_viewing_direction': self._suggest_viewing_direction(),
            'color_hex_codes': self._get_color_hex_codes(primary_colors + secondary_colors)
        }
    
    def _predict_gradient_type(self, burnsky_score, cloud_analysis):
        """é æ¸¬è‰²å½©æ¼¸è®Šé¡å‹"""
        if burnsky_score >= 70:
            return 'æ”¾å°„ç‹€æ¼¸è®Š'  # å¾åœ°å¹³ç·šå‘ä¸Šæ”¾å°„
        elif burnsky_score >= 50:
            return 'æ°´å¹³æ¼¸è®Š'  # æ°´å¹³å±¤æ¬¡åˆ†æ˜
        else:
            return 'æ•£å°„æ¼¸è®Š'  # æ•£äº‚åˆ†ä½ˆ
    
    def _estimate_color_duration(self, burnsky_score):
        """ä¼°ç®—è‰²å½©æŒçºŒæ™‚é–“"""
        if burnsky_score >= 80:
            return {'peak': '10-15åˆ†é˜', 'total': '25-35åˆ†é˜'}
        elif burnsky_score >= 60:
            return {'peak': '8-12åˆ†é˜', 'total': '20-30åˆ†é˜'}
        elif burnsky_score >= 40:
            return {'peak': '5-10åˆ†é˜', 'total': '15-25åˆ†é˜'}
        else:
            return {'peak': '3-8åˆ†é˜', 'total': '10-20åˆ†é˜'}
    
    def _suggest_viewing_direction(self):
        """å»ºè­°æœ€ä½³è§€è³æ–¹å‘"""
        # é¦™æ¸¯åœ°ç†ä½ç½®ï¼Œå»ºè­°è§€è³æ–¹å‘
        return {
            'sunset': 'è¥¿æ–¹è‡³è¥¿å—æ–¹',
            'sunrise': 'æ±æ–¹è‡³æ±å—æ–¹',
            'best_spots': ['ç¶­å¤šåˆ©äºæ¸¯', 'å¤ªå¹³å±±é ‚', 'è¥¿ç’°æµ·æ¿±', 'æ•¸ç¢¼æ¸¯']
        }
    
    def _get_color_hex_codes(self, color_names):
        """å°‡é¡è‰²åç¨±è½‰æ›ç‚ºåå…­é€²åˆ¶è‰²ç¢¼"""
        color_map = {
            'æ·±ç´…': '#B22222', 'æ©™ç´…': '#FF4500', 'é‡‘æ©™': '#FF8C00',
            'ç´«ç´…': '#DC143C', 'ç²‰ç´…': '#FF69B4', 'ç¥ç€': '#FFBF00',
            'æ©™è‰²': '#FFA500', 'æš–æ©™': '#FF7F50', 'æ·ºç´…': '#FF6347',
            'é‡‘é»ƒ': '#FFD700', 'ç²‰æ©™': '#FFAB91', 'æ·ºç²‰': '#FFB6C1',
            'æ·ºæ©™': '#FFDAB9', 'æš–é»ƒ': '#FFF8DC', 'æ·¡é»ƒ': '#FFFFE0',
            'ç±³ç™½': '#F5F5DC', 'æ·ºç°': '#D3D3D3', 'ç™½è‰²': '#FFFFFF',
            'æ·ºè—': '#ADD8E6', 'ç°ç™½': '#F8F8FF', 'æ·±ç´«': '#4B0082'
        }
        
        return {name: color_map.get(name, '#FFFFFF') for name in color_names if name in color_map}
    
    def analyze_cloud_thickness_and_color_visibility(self, weather_data, forecast_data):
        """
        åˆ†æé›²å±¤åšåº¦å’Œé¡è‰²å¯è¦‹åº¦ - å¢å¼·ç‰ˆ
        å€åˆ†ã€Œé¡è‰²ç‡’å¤©ã€vsã€Œæ˜æš—ç‡’å¤©ã€
        æ•´åˆè¡›æ˜Ÿé›²åœ–åˆ†ææŠ€è¡“
        """
        # é¦–å…ˆä½¿ç”¨åŸæœ‰é‚è¼¯ä½œç‚ºåŸºç¤
        analysis = {
            'cloud_thickness_level': 'unknown',
            'color_visibility_percentage': 50,
            'visibility_type': 'mixed',
            'photography_type': 'standard',
            'specific_recommendations': [],
            'color_expectations': [],
            'technical_details': {},
            'satellite_analysis': None,  # æ–°å¢è¡›æ˜Ÿåˆ†æçµæœ
            'enhanced_accuracy': False   # æ˜¯å¦ä½¿ç”¨äº†å¢å¼·åˆ†æ
        }
        
        try:
            # 1. å˜—è©¦è¼‰å…¥è¡›æ˜Ÿé›²åœ–åˆ†æå™¨
            try:
                from satellite_cloud_analyzer import SatelliteCloudAnalyzer
                satellite_analyzer = SatelliteCloudAnalyzer()
                
                # åŸ·è¡Œæ·±åº¦è¡›æ˜Ÿåˆ†æ
                satellite_result = satellite_analyzer.analyze_real_time_cloud_conditions(
                    weather_data, forecast_data
                )
                
                if satellite_result and satellite_result.get('data_confidence', 0) > 60:
                    # è¡›æ˜Ÿæ•¸æ“šå¯ä¿¡åº¦è¶³å¤ ï¼Œä½¿ç”¨å¢å¼·åˆ†æ
                    analysis = self._integrate_satellite_analysis(analysis, satellite_result)
                    analysis['enhanced_accuracy'] = True
                    analysis['satellite_analysis'] = satellite_result
                else:
                    # å›é€€åˆ°åŸæœ‰åˆ†ææ–¹æ³•
                    analysis = self._perform_basic_cloud_analysis(analysis, weather_data, forecast_data)
                    
            except ImportError:
                # è¡›æ˜Ÿåˆ†ææ¨¡çµ„ä¸å¯ç”¨ï¼Œä½¿ç”¨åŸæœ‰æ–¹æ³•
                analysis = self._perform_basic_cloud_analysis(analysis, weather_data, forecast_data)
                
        except Exception as e:
            analysis['error'] = f'é›²å±¤åšåº¦åˆ†æå¤±æ•—: {str(e)}'
            # æä¾›åŸºæœ¬é è¨­å€¼
            analysis.update({
                'cloud_thickness_level': 'moderate',
                'color_visibility_percentage': 50,
                'visibility_type': 'mixed',
                'photography_type': 'standard',
                'specific_recommendations': ['âš ï¸ åˆ†æç³»çµ±æš«æ™‚ä¸å¯ç”¨ï¼Œå»ºè­°çµåˆå¯¦éš›è§€å¯Ÿ'],
                'color_expectations': ['è«‹åƒè€ƒå¯¦æ™‚å¤©ç©ºç‹€æ³'],
                'technical_details': {'error': str(e)}
            })
        
        return analysis
    
    def _integrate_satellite_analysis(self, base_analysis, satellite_result):
        """æ•´åˆè¡›æ˜Ÿåˆ†æçµæœåˆ°åŸºç¤åˆ†æä¸­"""
        # å¾è¡›æ˜Ÿåˆ†æç²å–æ›´æº–ç¢ºçš„æ•¸æ“š
        visibility_prediction = satellite_result.get('visibility_prediction', {})
        cloud_analysis = satellite_result.get('cloud_analysis', {})
        burnsky_suitability = satellite_result.get('burnsky_suitability', {})
        photography_guidance = satellite_result.get('photography_guidance', {})
        
        # æ›´æ–°é¡è‰²å¯è¦‹åº¦
        color_visibility = visibility_prediction.get('color_visibility_percentage', 50)
        base_analysis['color_visibility_percentage'] = color_visibility
        
        # æ ¹æ“šè¡›æ˜Ÿæ•¸æ“šç¢ºå®šé›²å±¤åšåº¦ç­‰ç´š
        cloud_coverage = cloud_analysis.get('coverage_estimate', 50)
        dominant_type = cloud_analysis.get('dominant_type', 'unknown')
        
        if cloud_coverage <= 20 and dominant_type in ['clear', 'cirrus']:
            base_analysis['cloud_thickness_level'] = 'clear_to_thin'
            base_analysis['visibility_type'] = 'excellent_colors'
            base_analysis['photography_type'] = 'color_focused'
        elif cloud_coverage <= 50 and dominant_type in ['cumulus', 'mixed']:
            base_analysis['cloud_thickness_level'] = 'moderate'
            base_analysis['visibility_type'] = 'good_colors'
            base_analysis['photography_type'] = 'color_with_drama'
        elif cloud_coverage <= 80:
            base_analysis['cloud_thickness_level'] = 'thick'
            base_analysis['visibility_type'] = 'limited_colors'
            base_analysis['photography_type'] = 'contrast_focused'
        else:
            base_analysis['cloud_thickness_level'] = 'very_thick_overcast'
            base_analysis['visibility_type'] = 'brightness_only'
            base_analysis['photography_type'] = 'silhouette_only'
        
        # å¾æ”å½±æŒ‡å°ç²å–å»ºè­°
        if photography_guidance.get('composition_tips'):
            base_analysis['specific_recommendations'] = photography_guidance['composition_tips'][:4]
        
        # å¾å¯è¦‹åº¦é æ¸¬ç²å–é¡è‰²æœŸæœ›
        if visibility_prediction.get('dominant_colors_expected'):
            base_analysis['color_expectations'] = visibility_prediction['dominant_colors_expected']
        
        # è©³ç´°æŠ€è¡“è³‡è¨Š
        base_analysis['technical_details'] = {
            'satellite_confidence': satellite_result.get('data_confidence', 0),
            'cloud_coverage': cloud_coverage,
            'dominant_cloud_type': dominant_type,
            'atmospheric_transparency': satellite_result.get('visibility_prediction', {}).get('transparency_percentage', 50),
            'analysis_method': 'satellite_enhanced'
        }
        
        # æ ¹æ“šé©å®œåº¦æ·»åŠ ç‰¹æ®Šå»ºè­°
        suitability_level = burnsky_suitability.get('suitability_level', 'moderate')
        if suitability_level == 'excellent':
            base_analysis['specific_recommendations'].insert(0, 'ğŸŒŸ è¡›æ˜Ÿæ•¸æ“šé¡¯ç¤ºçµ•ä½³æ¢ä»¶ï¼')
        elif suitability_level == 'poor':
            base_analysis['specific_recommendations'].insert(0, 'ğŸ“¡ è¡›æ˜Ÿåˆ†æå»ºè­°ç­‰å¾…æ›´å¥½æ™‚æ©Ÿ')
        
        return base_analysis
    
    def _perform_basic_cloud_analysis(self, analysis, weather_data, forecast_data):
        """åŸ·è¡ŒåŸºç¤é›²å±¤åˆ†æï¼ˆåŸæœ‰é‚è¼¯çš„é‡æ§‹ç‰ˆæœ¬ï¼‰"""
        try:
            # 1. åŸºæ–¼å¤©æ°£æè¿°åˆ¤æ–·é›²å±¤åšåº¦
            cloud_analysis = self._analyze_weather_description_for_thickness(forecast_data)
            
            # 2. åŸºæ–¼æ°£è±¡æ•¸æ“šæ¨æ–·é›²å±¤å¯†åº¦  
            density_analysis = self._analyze_meteorological_density(weather_data)
            
            # 3. ç¶œåˆè©•ä¼°
            combined_score = (cloud_analysis['score'] + density_analysis['score']) / 2
            
            # 4. ç¢ºå®šé›²å±¤åšåº¦ç­‰ç´šï¼ˆæ²¿ç”¨åŸæœ‰é‚è¼¯ï¼‰
            if combined_score >= 80:
                analysis.update({
                    'cloud_thickness_level': 'clear_to_thin',
                    'color_visibility_percentage': 90,
                    'visibility_type': 'excellent_colors',
                    'photography_type': 'color_focused',
                    'color_expectations': ['é‡‘è‰²', 'æ©™è‰²', 'ç´…è‰²', 'ç´«è‰²', 'ç²‰ç´…è‰²'],
                    'specific_recommendations': [
                        'ğŸ¨ çµ•ä½³é¡è‰²ç‡’å¤©æ¢ä»¶ï¼',
                        'ğŸ“¸ å»ºè­°æ‹æ”ï¼šå…¨å½©è‰²æ¼¸è®Šã€é›²å½©ç´°ç¯€ã€å€’å½±æ•ˆæœ',
                        'â° å¯é æœŸï¼šæŒçºŒ15-30åˆ†é˜çš„è±å¯Œè‰²å½©è®ŠåŒ–',
                        'ğŸŒˆ è‰²æº«è®ŠåŒ–ï¼š3000K â†’ 2000K â†’ 1800K'
                    ]
                })
            elif combined_score >= 60:
                analysis.update({
                    'cloud_thickness_level': 'moderate',
                    'color_visibility_percentage': 65,
                    'visibility_type': 'good_colors',
                    'photography_type': 'color_with_drama',
                    'color_expectations': ['æ©™è‰²', 'ç´…è‰²', 'æ·±ç´…è‰²'],
                    'specific_recommendations': [
                        'ğŸŒ… è‰¯å¥½é¡è‰²ç‡’å¤©æ¢ä»¶',
                        'ğŸ“¸ å»ºè­°æ‹æ”ï¼šä¸»è¦è‰²å½©ã€é›²å±¤è¼ªå»“ã€å‰ªå½±æ•ˆæœ',
                        'â° å¯é æœŸï¼š10-20åˆ†é˜çš„æ˜é¡¯è‰²å½©',
                        'ğŸ­ é©åˆï¼šæˆ²åŠ‡æ€§æ§‹åœ–'
                    ]
                })
            elif combined_score >= 40:
                analysis.update({
                    'cloud_thickness_level': 'thick',
                    'color_visibility_percentage': 30,
                    'visibility_type': 'limited_colors',
                    'photography_type': 'contrast_focused',
                    'color_expectations': ['æ·¡æ©™è‰²', 'æš—ç´…è‰²'],
                    'specific_recommendations': [
                        'ğŸŒ«ï¸ åšé›²æ¢ä»¶ï¼Œä»¥æ˜æš—å°æ¯”ç‚ºä¸»',
                        'ğŸ“¸ å»ºè­°æ‹æ”ï¼šå‰ªå½±ã€é›²å±¤ç´‹ç†ã€æ˜æš—å±¤æ¬¡',
                        'â° å¯é æœŸï¼šå¾®å¼±è‰²å½©ï¼Œå¼·çƒˆæ˜æš—è®ŠåŒ–',
                        'ğŸ–¤ é©åˆï¼šé»‘ç™½æ”å½±ã€æƒ…ç·’æ°›åœ'
                    ]
                })
            else:
                analysis.update({
                    'cloud_thickness_level': 'very_thick_overcast',
                    'color_visibility_percentage': 10,
                    'visibility_type': 'brightness_only',
                    'photography_type': 'silhouette_only',
                    'color_expectations': ['æ¥µå¾®å¼±è‰²å½©'],
                    'specific_recommendations': [
                        'â˜ï¸ å¯†é›²å¤©æ°£ï¼Œä¸»è¦ç‚ºæ˜æš—è®ŠåŒ–',
                        'ğŸ“¸ å»ºè­°æ‹æ”ï¼šç´”å‰ªå½±ã€é›²å±¤å‹•æ…‹ã€å…‰ç·šç©¿é€',
                        'â° å¯é æœŸï¼š5-10åˆ†é˜çš„äº®åº¦è®ŠåŒ–',
                        'ğŸŒ† é©åˆï¼šæ¥µç°¡æ§‹åœ–ã€å½¢ç‹€è¡¨ç¾'
                    ]
                })
            
            # 5. æŠ€è¡“ç´°ç¯€
            analysis['technical_details'] = {
                'weather_score': cloud_analysis['score'],
                'density_score': density_analysis['score'],
                'combined_score': combined_score,
                'factors': cloud_analysis['factors'] + density_analysis['factors'],
                'analysis_method': 'basic_meteorological'
            }
            
        except Exception as e:
            analysis['error'] = f'åŸºç¤é›²å±¤åˆ†æå¤±æ•—: {str(e)}'
        
        return analysis

    def _analyze_weather_description_for_thickness(self, forecast_data):
        """åˆ†æå¤©æ°£æè¿°ä»¥è©•ä¼°é›²å±¤åšåº¦"""
        analysis = {
            'score': 50,  # é è¨­ä¸­ç­‰åˆ†æ•¸
            'factors': [],
            'keywords_found': []
        }
        
        if not forecast_data or 'forecastDesc' not in forecast_data:
            analysis['factors'].append('å¤©æ°£æè¿°è³‡æ–™ä¸å¯ç”¨')
            return analysis
        
        description = forecast_data['forecastDesc'].lower()
        
        # é›²å±¤ç›¸é—œé—œéµè©èˆ‡åˆ†æ•¸
        cloud_keywords = {
            # æ™´æœ—å¤©æ°£ (é«˜åˆ†æ•¸)
            'æ™´æœ—': 95, 'å¤©æ™´': 90, 'æ™´å¤©': 88,
            
            # éƒ¨åˆ†é›²å±¤ (ä¸­é«˜åˆ†æ•¸)
            'éƒ¨åˆ†æ™‚é–“æœ‰é™½å…‰': 75, 'çŸ­æš«æ™‚é–“æœ‰é™½å…‰': 65, 'é–“ä¸­æœ‰é™½å…‰': 70,
            
            # å¤šé›² (ä¸­ç­‰åˆ†æ•¸)
            'å¤šé›²': 45, 'å¤§è‡´å¤šé›²': 35, 'ä¸»è¦å¤šé›²': 30,
            
            # å¯†é›²èˆ‡æƒ¡åŠ£å¤©æ°£ (ä½åˆ†æ•¸)
            'å¯†é›²': 15, 'é™°å¤©': 20, 'å¤§è‡´é™°å¤©': 25,
            'é›·æš´': 10, 'é›¨': 10, 'å¤§é›¨': 5, 'æš´é›¨': 5,
            'è–„éœ§': 30, 'éœ§': 20, 'æ¿ƒéœ§': 10
        }
        
        # æª¢æŸ¥é—œéµè©
        matched_scores = []
        for keyword, score in cloud_keywords.items():
            if keyword in description:
                matched_scores.append(score)
                analysis['keywords_found'].append(keyword)
                analysis['factors'].append(f'æª¢æ¸¬åˆ°: {keyword} (åˆ†æ•¸: {score})')
        
        # è¨ˆç®—æœ€çµ‚åˆ†æ•¸
        if matched_scores:
            # å¦‚æœæ‰¾åˆ°å¤šå€‹é—œéµè©ï¼Œå–å¹³å‡å€¼ä½†åå‘è¼ƒä½åˆ†æ•¸ï¼ˆä¿å®ˆé æ¸¬ï¼‰
            analysis['score'] = (min(matched_scores) * 0.6 + max(matched_scores) * 0.4)
        else:
            analysis['factors'].append('æœªæª¢æ¸¬åˆ°æ˜ç¢ºé›²å±¤é—œéµè©ï¼Œä½¿ç”¨é è¨­åˆ†æ•¸')
        
        return analysis
    
    def _analyze_meteorological_density(self, weather_data):
        """åŸºæ–¼æ°£è±¡æ•¸æ“šåˆ†æé›²å±¤å¯†åº¦"""
        analysis = {
            'score': 50,  # é è¨­åˆ†æ•¸
            'factors': [],
            'measurements': {}
        }
        
        factors_scores = []
        
        try:
            # 1. UVæŒ‡æ•¸åˆ†æ (åæ˜ é›²å±¤é®è”½)
            if weather_data.get('uvindex') and weather_data['uvindex'].get('data'):
                uv_data = weather_data['uvindex']['data']
                if uv_data and len(uv_data) > 0:
                    uv_value = uv_data[0].get('value', 0)
                    # UVæŒ‡æ•¸è¶Šé«˜ï¼Œé›²å±¤é®è”½è¶Šå°‘
                    uv_score = min(100, uv_value * 12)  # UV8+ = 96åˆ†
                    factors_scores.append(uv_score)
                    analysis['measurements']['uv_index'] = uv_value
                    analysis['factors'].append(f'UVæŒ‡æ•¸: {uv_value} (é›²å±¤é€æ˜åº¦åˆ†æ•¸: {uv_score:.1f})')
            
            # 2. æ¿•åº¦åˆ†æ
            if weather_data.get('humidity') and weather_data['humidity'].get('data'):
                hko_humidity = next((h for h in weather_data['humidity']['data'] 
                                   if h.get('place') == 'é¦™æ¸¯å¤©æ–‡å°'), None)
                if hko_humidity:
                    humidity = hko_humidity.get('value', 70)
                    # æ¿•åº¦å½±éŸ¿èƒ½è¦‹åº¦èˆ‡é›²å±¤å½¢æˆ
                    humidity_score = max(10, 110 - humidity)  # æ¿•åº¦è¶Šä½åˆ†æ•¸è¶Šé«˜
                    factors_scores.append(humidity_score)
                    analysis['measurements']['humidity'] = humidity
                    analysis['factors'].append(f'æ¿•åº¦: {humidity}% (èƒ½è¦‹åº¦åˆ†æ•¸: {humidity_score:.1f})')
            
            # 3. é™é›¨é‡åˆ†æ
            if weather_data.get('rainfall') and weather_data['rainfall'].get('data'):
                total_rainfall = sum(r.get('value', 0) for r in weather_data['rainfall']['data'] 
                                   if isinstance(r, dict))
                if total_rainfall > 0:
                    # é™é›¨è¡¨ç¤ºæœ‰åšé›²å±¤
                    rain_score = max(5, 60 - total_rainfall * 10)
                    factors_scores.append(rain_score)
                    analysis['measurements']['rainfall'] = total_rainfall
                    analysis['factors'].append(f'é™é›¨é‡: {total_rainfall}mm (é›²å±¤åˆ†æ•¸: {rain_score:.1f})')
                else:
                    # ç„¡é™é›¨æ˜¯å¥½å¾µè±¡
                    factors_scores.append(75)
                    analysis['factors'].append('ç„¡é™é›¨ (æœ‰åˆ©æ–¼ç‡’å¤©)')
            
            # 4. è¨ˆç®—ç¶œåˆåˆ†æ•¸
            if factors_scores:
                analysis['score'] = sum(factors_scores) / len(factors_scores)
            else:
                analysis['factors'].append('æ°£è±¡æ•¸æ“šä¸å®Œæ•´ï¼Œä½¿ç”¨é è¨­åˆ†æ•¸')
                
        except Exception as e:
            analysis['factors'].append(f'æ°£è±¡æ•¸æ“šåˆ†æéŒ¯èª¤: {str(e)}')
        
        return analysis
